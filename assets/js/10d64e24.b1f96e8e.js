"use strict";(self.webpackChunktest=self.webpackChunktest||[]).push([[8],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,p=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=l(n),u=o,h=d["".concat(p,".").concat(u)]||d[u]||c[u]||r;return n?a.createElement(h,i(i({ref:t},m),{},{components:n})):a.createElement(h,i({ref:t},m))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},994:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:2},i=void 0,s={unversionedId:"reference/Entities",id:"reference/Entities",title:"Entities",description:'Entities are the building blocks of the world. Any "thing" that exists inside your world is an entity (player, wall, lights, etc.). They hold data in the form of components, which can hold values, and also represent relationships and tags.',source:"@site/docs/reference/Entities.md",sourceDirName:"reference",slug:"/reference/Entities",permalink:"/BagelECS/docs/reference/Entities",draft:!1,editUrl:"https://github.com/Bagel03/BagelECS/edit/master/docs/docs/reference/Entities.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"World",permalink:"/BagelECS/docs/reference/World"},next:{title:"Components",permalink:"/BagelECS/docs/reference/Components"}},p={},l=[{value:"Creating",id:"creating",level:2},{value:"Removing",id:"removing",level:2},{value:"Adding Components",id:"adding-components",level:2},{value:"Removing Components",id:"removing-components",level:2},{value:"Checking for Components",id:"checking-for-components",level:2},{value:"Getting Data",id:"getting-data",level:2},{value:"Updating Data",id:"updating-data",level:2},{value:"Extras",id:"extras",level:2},{value:"<code>tag()</code> and <code>removeTag()</code>",id:"tag-and-removetag",level:3},{value:"Hierarchy Methods",id:"hierarchy-methods",level:3},{value:"Relationships",id:"relationships",level:3}],m={toc:l},d="wrapper";function c(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,'Entities are the building blocks of the world. Any "thing" that exists inside your world is an entity (player, wall, lights, etc.). They hold data in the form of ',(0,o.kt)("a",{parentName:"p",href:"/BagelECS/docs/reference/Components"},"components"),", which can hold values, and also represent relationships and tags."),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Entities are actually just ",(0,o.kt)("inlineCode",{parentName:"p"},"number"),"s, which is one of the reasons BagelECS is so fast. So while to you it looks like you are calling ",(0,o.kt)("inlineCode",{parentName:"p"},"ent.add()"),", you are actually calling ",(0,o.kt)("inlineCode",{parentName:"p"},"(0).add()"),". This means serializing entities is very easy, and you can pass them around without almost any performance hit."),(0,o.kt)("p",{parentName:"admonition"},"BagelECS adds some methods to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Number")," prototype, which is generally ",(0,o.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/6223449/why-is-it-frowned-upon-to-modify-javascript-objects-prototypes"},"frowned upon"),". However, it is not an issue unless you are using other monkey patching libraries that modify the same entity methods."),(0,o.kt)("p",{parentName:"admonition"},"That being said, most entity methods require that it's ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," value is a valid entity in the global ",(0,o.kt)("inlineCode",{parentName:"p"},"World"),", so please don't use ",(0,o.kt)("inlineCode",{parentName:"p"},"(3.14).add(new Pos())")," in your code. Use the provided method ",(0,o.kt)("inlineCode",{parentName:"p"},"World.prototype.spawn()")," to get an entity reference")),(0,o.kt)("h2",{id:"creating"},"Creating"),(0,o.kt)("p",null,"To create an entity and get a reference to it, use ",(0,o.kt)("inlineCode",{parentName:"p"},"World.prototype.spawn"),". This automatically adds the entity to the world as well."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new World(100);\nconst ent = world.spawn();\n")),(0,o.kt)("h2",{id:"removing"},"Removing"),(0,o.kt)("p",null,"To remove an entity from a world, use ",(0,o.kt)("inlineCode",{parentName:"p"},"World.prototype.destroy"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"world.destory(ent);\n")),(0,o.kt)("h2",{id:"adding-components"},"Adding Components"),(0,o.kt)("p",null,"To add a component, use ",(0,o.kt)("inlineCode",{parentName:"p"},"Entity.prototype.add"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"ent.add(new Pos({ x: 1, y: 2 }));\n")),(0,o.kt)("p",null,"If you want to use a custom component ID (To allow multiple components of the same type), supply an ",(0,o.kt)("inlineCode",{parentName:"p"},"intoId")," as the second argument."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'ent.add("Player 1", "name");\nent.add("Red", "team");\n')),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"Built-in components (created with ",(0,o.kt)("inlineCode",{parentName:"p"},"Component()"),") can not use custom component ID's")),(0,o.kt)("h2",{id:"removing-components"},"Removing Components"),(0,o.kt)("p",null,"To remove a given component from an entity, use ",(0,o.kt)("inlineCode",{parentName:"p"},"Entity.prototype.remove"),", with an ",(0,o.kt)("inlineCode",{parentName:"p"},"intoId")," pointing to your component:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'ent.remove(Pos);\nent.remove("name");\nent.remove("team");\n')),(0,o.kt)("h2",{id:"checking-for-components"},"Checking for Components"),(0,o.kt)("p",null,"To find if a given entity has a given component, use ",(0,o.kt)("inlineCode",{parentName:"p"},"Entity.prototype.has"),", which also takes an single ",(0,o.kt)("inlineCode",{parentName:"p"},"intoId"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'ent.has(Pos);\nent.has("name");\n')),(0,o.kt)("p",null,"If you need to get all the components an entity has, use ",(0,o.kt)("inlineCode",{parentName:"p"},"Entity.prototype.components"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const componentIds = ent.components();\nif(componentIds.has(Pos.getId())) {\n    ...\n}\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," This returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"ReadonlySet<number>")," containing all the component ID's an entity has. It does not include the actual component data associated with this entity."),(0,o.kt)("h2",{id:"getting-data"},"Getting Data"),(0,o.kt)("p",null,"To get a component or a components data from an entity, use ",(0,o.kt)("inlineCode",{parentName:"p"},"Entity.prototype.get"),". There are a few different signatures, all meant to provide the most type inference with the least boilerplate, however, they all require a ",(0,o.kt)("inlineCode",{parentName:"p"},"typeId"),"."),(0,o.kt)("p",null,"When using a base ",(0,o.kt)("inlineCode",{parentName:"p"},"typeId")," literal (most of the time a ",(0,o.kt)("inlineCode",{parentName:"p"},"number")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),"), BagelECS doesn't have enough information to know what kind of data is stored there at compile time. Because of this, you have to specify it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'ent.get("name"); // Return type of any\nent.get<string>("team"); // string\n')),(0,o.kt)("p",null,"However, if you are getting a whole instance of a class (from a library or somewhere else), BagelECS fills in the type for you when you supply the class constructor:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { Object3D } from "three";\n\nent.get(Object3D); // Object3D\n')),(0,o.kt)("p",null,"If you are using built-in components, it also remembers what your schema looks like and uses that to find a return type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const Rect = Component({\n    pos: {\n        x: Type.number,\n        y: Type.number,\n    },\n    col: Type.string,\n});\n\nent.get(Rect.pos.x); // Infered return type of number\nent.get(Rect.pos.y); // number\nent.get(Rect.col); // string\n")),(0,o.kt)("admonition",{title:"Built-in vs External component API's",type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"You may have noticed how built-in components differ from external components when getting data:"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// External (Built without Component())\nent.get(Object3D).position.x;\n\n// Built-in (With Component())\nent.get(Rect.pos.x);\n")),(0,o.kt)("p",{parentName:"admonition"},"Notice how you specify the property you want as part of the argument when using built-in components. This is because BagelECS doesn't actually hold onto the whole ",(0,o.kt)("inlineCode",{parentName:"p"},"Rect")," object, only the properties it needs, which is the reason it is so fast. However, this means that if you try to get the plain ",(0,o.kt)("inlineCode",{parentName:"p"},"Rect")," object, things will break."),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"ent.get(Rect).pos.x++; // Error: ent.get(...).pos is undefined\n")),(0,o.kt)("p",{parentName:"admonition"},"For a longer explanation on why this is the case, see this."),(0,o.kt)("p",{parentName:"admonition"},"However, this means that you have to get the most specific property you can while using built-in components, or it will break:"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const Deep = Component({\n    a: {\n        b: {\n            c: {\n                prop: Type.number,\n            },\n        },\n    },\n});\n\nent.get(Deep).a.b.c.prop; // \u274c Breaks\nent.get(Deep.a).b.c.prop; // \u274c Breaks\nent.get(Deep.a.b.c).prop; // \u274c Breaks\n\nent.get(Deep.a.b.c.prop); // \u2705 Works\n")),(0,o.kt)("p",{parentName:"admonition"},"As of right now, BagelECS is not smart enough to emit a compile time error for these kind of mistakes, however it will mark the return type as ",(0,o.kt)("inlineCode",{parentName:"p"},"any"),", so if you are expecting ts to infer something and it doesn't it could be a clue you messed up somewhere"),(0,o.kt)("p",{parentName:"admonition"},"Note that this obviously does not work with external components"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'ent.get(Object3D.position.x); // Object3D does not have property "position"\n'))),(0,o.kt)("h2",{id:"updating-data"},"Updating Data"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"[!warning]","\nIt can be tempting to do something like this:"),(0,o.kt)("pre",{parentName:"blockquote"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"ent.get(Rect.pos.x)++;\n")),(0,o.kt)("p",{parentName:"blockquote"},"However, this will not effect the data that is held inside the entity, because the call to ",(0,o.kt)("inlineCode",{parentName:"p"},"ent.get")," returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"number"),", which is ",(0,o.kt)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/pass-by-value-and-pass-by-reference-in-javascript/#"},"passed by value"),' in js, so any modifications will effect the "new" ',(0,o.kt)("inlineCode",{parentName:"p"},"number"),", not the one that is stored."),(0,o.kt)("p",{parentName:"blockquote"},"If you are using external components, or have a non-primitive type in your schema, you can update sub-properties of those components using the assignment operator")),(0,o.kt)("p",null,"There are 2 ways of updating component data that already exists on an entity: ",(0,o.kt)("inlineCode",{parentName:"p"},"Entity.prototype.update")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Entity.prototype.getSlowRef"),":"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"update"),' can update one property at a time and works very similar to add, except you have to specify the full "path" to your data when using built-in components:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// External components\nent.update(new Object3D(..)); // Overwrite the object I already have stored here with something new\n\n// Built-in components\nent.update(Rect.pos.x, 10);\n")),(0,o.kt)("p",null,"Notice how you still have to follow the same rules that ",(0,o.kt)("inlineCode",{parentName:"p"},"Entity.prototype.get")," sets when updating data."),(0,o.kt)("p",null,"However, using update can get cumbersome fairly often:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// Move the entity 1 unit to the right\nent.update(Rect.pos.x, ent.get(Rect.pos.x) + 1);\n")),(0,o.kt)("p",null,"So for cases where performance is not a concern, BagelECS provides ",(0,o.kt)("inlineCode",{parentName:"p"},"getSlowRef"),". As it's name implies, it is ",(0,o.kt)("em",{parentName:"p"},"much")," slower than other methods, but it provides a much better developer experience:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const ref = ent.getSlowRef();\nref[Rect.pos.x]++;\n")),(0,o.kt)("p",null,"It returns a proxy, which allows you to get and set any component values using bracket syntax instead of ",(0,o.kt)("inlineCode",{parentName:"p"},".get")," and ",(0,o.kt)("inlineCode",{parentName:"p"},".update"),". However, the property keys (what you put inside the brackets) follows the same rules as ",(0,o.kt)("inlineCode",{parentName:"p"},".get"),", so the following would still not work:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"ref[Rect].pos.x++; // \u274c Fails again\n")),(0,o.kt)("h2",{id:"extras"},"Extras"),(0,o.kt)("p",null,"There are also a few more entity methods that you should know about:"),(0,o.kt)("h3",{id:"tag-and-removetag"},(0,o.kt)("inlineCode",{parentName:"h3"},"tag()")," and ",(0,o.kt)("inlineCode",{parentName:"h3"},"removeTag()")),(0,o.kt)("p",null,"Attach a tag component (a component without any associated properties/data) to an entity:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'ent.tag("enemy");\nent.removeTag("alive");\n')),(0,o.kt)("p",null,"These interact the same way as other components when using ",(0,o.kt)("inlineCode",{parentName:"p"},".has")," or world queries:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// All entities that have been taged as alive\nworld.query("alive").forEach(..)\n\n// See if it has a tag\nent.has("enemy");\n')),(0,o.kt)("h3",{id:"hierarchy-methods"},"Hierarchy Methods"),(0,o.kt)("p",null,"One of BagelECS's secondary goals is to provide an easy to use, fast hierarchy API. More information can be found on the ",(0,o.kt)("a",{parentName:"p",href:"Hierarchy"},"hierarchy page")),(0,o.kt)("h3",{id:"relationships"},"Relationships"),(0,o.kt)("p",null,"BagelECS also supports ",(0,o.kt)("a",{parentName:"p",href:"https://flecs.dev"},"flecs")," style relationships, documentation and related methods are on the ",(0,o.kt)("a",{parentName:"p",href:"Relationships"},"relationships page")))}c.isMDXComponent=!0}}]);