"use strict";(self.webpackChunktest=self.webpackChunktest||[]).push([[806],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(n),c=i,h=m["".concat(l,".").concat(c)]||m[c]||d[c]||o;return n?r.createElement(h,a(a({ref:t},u),{},{components:n})):r.createElement(h,a({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:i,a[1]=s;for(var p=2;p<o;p++)a[p]=n[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9342:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var r=n(7462),i=(n(7294),n(3905));const o={sidebar_position:5},a=void 0,s={unversionedId:"reference/Queries",id:"reference/Queries",title:"Queries",description:"Quieres represent sets of entities that fit some defined criteria. They are most often used within systems, but you can create one-time queries just as easily.",source:"@site/docs/reference/Queries.md",sourceDirName:"reference",slug:"/reference/Queries",permalink:"/BagelECS/docs/reference/Queries",draft:!1,editUrl:"https://github.com/Bagel03/BagelECS/edit/master/docs/docs/reference/Queries.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Resources",permalink:"/BagelECS/docs/reference/Resources"},next:{title:"Systems",permalink:"/BagelECS/docs/reference/Systems"}},l={},p=[{value:"Modifiers",id:"modifiers",level:2},{value:"Built-in Modifiers",id:"built-in-modifiers",level:3},{value:"Within Systems",id:"within-systems",level:2},{value:"One-time Queries",id:"one-time-queries",level:2},{value:"Iterating through a query",id:"iterating-through-a-query",level:2}],u={toc:p},m="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Quieres represent sets of ",(0,i.kt)("a",{parentName:"p",href:"/BagelECS/docs/reference/Entities"},"entities")," that fit some defined criteria. They are most often used within systems, but you can create one-time queries just as easily."),(0,i.kt)("h2",{id:"modifiers"},"Modifiers"),(0,i.kt)("p",null,"You very rarely have to manually create a system, instead most API's take 1 or more ",(0,i.kt)("inlineCode",{parentName:"p"},"QueryModifiers"),", functions that have the signature:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"type QueryModifier = (components: Set<number>) => boolean;\n")),(0,i.kt)("p",null,"Where ",(0,i.kt)("inlineCode",{parentName:"p"},"components")," is a set of all the component ID's that belong to the entity. For an entity to be part of a query, it must pass whatever modifier is defined for that query."),(0,i.kt)("h3",{id:"built-in-modifiers"},"Built-in Modifiers"),(0,i.kt)("p",null,"For your convenince, BagelECS comes with a few built in query modifier factories"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"With(...components: number[])"),": Returns true if an entity contains ",(0,i.kt)("em",{parentName:"li"},"every")," supplied component"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Without(...components: number[])"),": Returns true if an entity has ",(0,i.kt)("em",{parentName:"li"},"none")," of the supplied"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"All(...modifiers: QueryModifier[])"),": Returns true if an entity passes all of the supplied")),(0,i.kt)("h2",{id:"within-systems"},"Within Systems"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"System()")," function takes one argument, a tree of query modifiers. These will be associated with returned system class's ",(0,i.kt)("inlineCode",{parentName:"p"},"entities")," property."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class SysA extends System(With(ComponentA.getId())) {\n    update() {\n        // Points to a query for all entities with ComponentA\n        this.entities;\n    }\n}\n\nclass SysBAndC extends System({b: With(ComponentB.getId()), c: With(ComponentC.getId())) {\n    update() {\n        // Now this.entities is not a valid query, but an object that contains 2 queries:\n        this.entities instanceof Query; // \u274c False\n\n        this.entities.b instanceof Query; // \u2705 True\n        this.entities.c instanceof Query; // \u2705 True\n    }\n}\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"BagelECS also provides a shorthand for specifying query modifiers, which are as follows:"),(0,i.kt)("p",{parentName:"admonition"},"Any ",(0,i.kt)("inlineCode",{parentName:"p"},"intoId")," will be converted to ",(0,i.kt)("inlineCode",{parentName:"p"},"With(argId)"),", so you can leave out the ",(0,i.kt)("inlineCode",{parentName:"p"},"With()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".getId()")),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class SysD extends System(ComponentD) {}\nclass SysFAndG extends System({ f: ComponentF, g: ComponentG }) {}\n")),(0,i.kt)("p",{parentName:"admonition"},"Any array will be converted to ",(0,i.kt)("inlineCode",{parentName:"p"},"All()"),":"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class SysH extends System([\n    With(ComponentH_a.getId()),\n    With(componentH_b.getId()),\n]) {}\n")),(0,i.kt)("p",{parentName:"admonition"},"All shorthand is recusive, so the previous example can be written without the ",(0,i.kt)("inlineCode",{parentName:"p"},"With()")," (It will be inferred by the first rule):"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class SysH extends System([ComponentH_a, ComponentH_b]) {}\n")),(0,i.kt)("p",{parentName:"admonition"},"Note that while these are nice while writing code, they are slightly more difficult to understand and read, so it could still be better to formally express your intentions with the builtin modifiers")),(0,i.kt)("h2",{id:"one-time-queries"},"One-time Queries"),(0,i.kt)("p",null,"Sometimes, it is valueable to query for specific entities at one specific time. It is not worth it to create a new system that only updates once, and for that reason BagelECS exposes ",(0,i.kt)("inlineCode",{parentName:"p"},"World.prototype.query()"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"world.query(With(ComponentA));\n")),(0,i.kt)("p",null,"This method also takes the same shorthand as the ",(0,i.kt)("inlineCode",{parentName:"p"},"System()")," function."),(0,i.kt)("h2",{id:"iterating-through-a-query"},"Iterating through a query"),(0,i.kt)("p",null,"Once you define a query, it keeps track of which entities to target while they are changing inside the world. To loop through all the entities targeted at any given time, BagelECS provides 2 methods: Iterators and ",(0,i.kt)("inlineCode",{parentName:"p"},".forEach"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const query = world.query(ComponentA);\n\nfor (const entity of query) {\n    console.log(entity.get(ComponentA));\n}\n\nquery.forEach((ent) => console.log(ent.get(ComponentA)));\n")),(0,i.kt)("p",null,"They both do the same thing, but looks very different. Some people favor the newer ",(0,i.kt)("inlineCode",{parentName:"p"},".forEach")," methods that are being added to the standard library, and others like old school for loops, so use whichever you like."),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"In my local testing, iterators (",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loops) were significantly slower than ",(0,i.kt)("inlineCode",{parentName:"p"},".forEach"),". I suggest testing both, as they could have wildly different performance characteristics based on your program and its host browser.")))}d.isMDXComponent=!0}}]);