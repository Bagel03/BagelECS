"use strict";(self.webpackChunktest=self.webpackChunktest||[]).push([[171],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>y});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),m=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=m(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=m(n),c=r,y=p["".concat(l,".").concat(c)]||p[c]||u[c]||i;return n?a.createElement(y,o(o({ref:t},d),{},{components:n})):a.createElement(y,o({ref:t},d))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,o[1]=s;for(var m=2;m<i;m++)o[m]=n[m];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},293:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>m});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:7},o=void 0,s={unversionedId:"reference/Multithreading",id:"reference/Multithreading",title:"Multithreading",description:"BagelECS provides a simple way to add multithreading to your application through JS worker threads. Most things should be seamless, but there are a few important limitations that you should know about.",source:"@site/docs/reference/Multithreading.md",sourceDirName:"reference",slug:"/reference/Multithreading",permalink:"/BagelECS/docs/reference/Multithreading",draft:!1,editUrl:"https://github.com/Bagel03/BagelECS/edit/master/docs/docs/reference/Multithreading.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Systems",permalink:"/BagelECS/docs/reference/Systems"},next:{title:"Relationships",permalink:"/BagelECS/docs/reference/Relationships"}},l={},m=[{value:"System Multithreading",id:"system-multithreading",level:2},{value:"Updating",id:"updating",level:2},{value:"SIMD Multithreading",id:"simd-multithreading",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Resources",id:"resources",level:3},{value:"<code>Any</code> Component Types",id:"any-component-types",level:3},{value:"Adding and Removing Entities and Components",id:"adding-and-removing-entities-and-components",level:3}],d={toc:m},p="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"BagelECS provides a simple way to add multithreading to your application through JS ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers"},"worker threads"),". Most things should be seamless, but there are a few important limitations that you should know about."),(0,r.kt)("h2",{id:"system-multithreading"},"System Multithreading"),(0,r.kt)("p",null,"System multithreading refers to running a whole system on its own thread. It's queries will still be based on the main thread, but the logic will not interrupt anything on it's origin thread. Telling BagelECS to run a system on its own thread takes 2 steps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"First, create your system in a separate file, and register it as a remote system:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="system.ts"',title:'"system.ts"'},'import { registerRemoteSystem, System } from "bagelecs/remote";\n\nimport { Pos } from "./components/position";\n\nexport class MySystem extends System(Pos) {\n    update() {\n        // Move all entities to the right\n        this.entities.forEach((ent) =>\n            ent.update(Pos.x, ent.get(Pos.x) + 1)\n        );\n    }\n}\n\n// Use this:\nregisterRemoteSystem(MySystem);\n')),(0,r.kt)("admonition",{parentName:"li",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Notice that ",(0,r.kt)("inlineCode",{parentName:"p"},"registerRemoteSystem")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"System")," are imported from ",(0,r.kt)("inlineCode",{parentName:"p"},"bagelecs/remote"),", not from the base ",(0,r.kt)("inlineCode",{parentName:"p"},"bagelecs")," pacakge."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Now use ",(0,r.kt)("inlineCode",{parentName:"p"},"World.prototype.addRemoteSystem")," and pass in the path to your system file:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="main.ts"',title:'"main.ts"'},'const world = new World(100);\n\nworld.addRemoteSystem("./system.js");\n')),(0,r.kt)("admonition",{parentName:"li",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Make sure that the server you are using can give bagelecs a full path to your system file. This is the source of almost all issues with starting a remote system,\nas in many environments bagelecs will look for ",(0,r.kt)("inlineCode",{parentName:"p"},"./system.js")," inside of ",(0,r.kt)("inlineCode",{parentName:"p"},"node_modules/bagelecs"),", which will of course fail. Also note the ",(0,r.kt)("inlineCode",{parentName:"p"},".js")," extension, as that is what will be imported at runtime, even if it doesn't exist at compile time.")),(0,r.kt)("p",{parentName:"li"},"You should see a message in the console verifying that your system is working."))),(0,r.kt)("h2",{id:"updating"},"Updating"),(0,r.kt)("p",null,"Remote systems are updated just like any other system, either all at once ",(0,r.kt)("inlineCode",{parentName:"p"},"world.update()")," or by passing the system into the ",(0,r.kt)("inlineCode",{parentName:"p"},"update()")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { MySystem } from "./system";\n\nworld.update(MySystem);\n')),(0,r.kt)("h2",{id:"simd-multithreading"},"SIMD Multithreading"),(0,r.kt)("p",null,"SIMD (",(0,r.kt)("em",{parentName:"p"},"single instruction multiple data"),") refers to running ths same instruction (function) over lots of data (in an ECS's case different entities and their components).\nThis would mean running a single system in multiple threads, and evenly distributing the system's targeted entities among the threads. BagelECS allows you to accomplish this by providing a second argument to ",(0,r.kt)("inlineCode",{parentName:"p"},"World.prototype.addRemoteSystem"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"numThreads"),". BagelECS will then load your system on that many worker threads, and distribute entities evenly across them:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="main.ts"',title:'"main.ts"'},'const world = new World(100);\n\nworld.addRemoteSystem("./system.js", 4);\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"No change to your system (and its containing file) are needed, just provide the extra parameter in your base thread.")),(0,r.kt)("h2",{id:"limitations"},"Limitations"),(0,r.kt)("p",null,"Due to the nature of worker threads, there are quite a few things that bagelECS can not (realistically) do, including:"),(0,r.kt)("h3",{id:"resources"},"Resources"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/BagelECS/docs/reference/Resources"},"Resources")," are not automatically synced between threads. This is because diffing all of your resources every frame would be too expensive and would most likely be slower than having no multithreading at all."),(0,r.kt)("h3",{id:"any-component-types"},(0,r.kt)("inlineCode",{parentName:"h3"},"Any")," Component Types"),(0,r.kt)("p",null,"Similar to resources, any component property that is of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Type.any")," is not automatically synced. ",(0,r.kt)("a",{parentName:"p",href:"/BagelECS/docs/reference/Components#external-components"},"External components")," (Not made with ",(0,r.kt)("inlineCode",{parentName:"p"},"Component()"),"), as well as ",(0,r.kt)("inlineCode",{parentName:"p"},"Type.string")," are also not synced."),(0,r.kt)("h3",{id:"adding-and-removing-entities-and-components"},"Adding and Removing Entities and Components"),(0,r.kt)("p",null,"Currently, worker systems can only edit data that already exists. BagelECS does not allow adding or removing entities from a world, or adding or removing components from an entity."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"")))}u.isMDXComponent=!0}}]);